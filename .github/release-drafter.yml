name-template: "v$RESOLVED_VERSION"
tag-template: "v$RESOLVED_VERSION"

template: |
  # v$RESOLVED_VERSION ($(date +'%Y-%m-%d'))
  
  $COMMIT_MESSAGES
  
  **Full Changelog**: https://github.com/$OWNER/$REPOSITORY/compare/$PREVIOUS_TAG...$RESOLVED_VERSION

categories:
  - title: "🚨 Breaking Changes"
    labels: ["breaking-change"]
  - title: "✨ Features"
    labels: ["feature"]
  - title: "🐛 Bug Fixes"
    labels: ["bug"]
  - title: "🛠 Enhancements"
    labels: ["enhancement"]
  - title: "📦 Dependencies"
    labels: ["dependencies"]
    collapse-after: 2
  - title: "📋 Other Changes"
    labels: []

change-template: ""

template-variables:
  COMMIT_MESSAGES: $COMMITS_TEMPLATE

replacers:
  - search: '\$COMMITS_TEMPLATE'
    replace: >-
      ${{
        // Create commit groups based on the categories configuration
        const commitGroups = {};
        categories.forEach(category => {
          // Create a key from the title by removing emojis and spaces
          const key = category.title.replace(/[^\w\s]/g, '').replace(/\s+/g, '').toLowerCase();
          commitGroups[key] = {
            title: category.title,
            labels: category.labels || [],
            items: []
          };
        });

        // Add a catch-all for commits that don't match any category
        commitGroups.other = {
          title: "📋 Other Changes",
          items: []
        };

        commits.forEach(commit => {
          const message = commit.message.trim();
          const author = commit.author ? ` by @${commit.author.login}` : '';
          const prNumber = commit.linkedPullNumbers && commit.linkedPullNumbers[0] 
            ? ` in #${commit.linkedPullNumbers[0]}`
            : '';
          
          const entry = `${message}${author}${prNumber}`;
          
          let assigned = false;
          
          // First check for breaking changes
          const isBreaking = commit.body && commit.body.includes("BREAKING CHANGE");
          if (isBreaking) {
            commitGroups.breakingchanges.items.push(entry);
            assigned = true;
          }
          
          // Then check commit labels
          if (!assigned && commit.labels && commit.labels.length > 0) {
            for (const groupKey in commitGroups) {
              const group = commitGroups[groupKey];
              if (group.labels && group.labels.length > 0) {
                const hasMatchingLabel = commit.labels.some(label => 
                  group.labels.includes(label.name)
                );
                if (hasMatchingLabel) {
                  group.items.push(entry);
                  assigned = true;
                  break;
                }
              }
            }
          }
          
          // If not assigned by labels, try to categorize by commit type
          if (!assigned) {
            const typeMatch = message.match(/^(\w+)(\([^)]+\))?:/i);
            const type = typeMatch ? typeMatch[1].toLowerCase() : 'other';
            
            // Map commit types to category keys
            const typeMapping = {
              feat: 'features',
              fix: 'bugfixes',
              perf: 'other',
              refactor: 'enhancements',
              docs: 'other',
              test: 'other',
              build: 'other',
              ci: 'other',
              style: 'other',
              chore: 'other',
              revert: 'other'
            };
            
            const categoryKey = typeMapping[type] || 'other';
            if (commitGroups[categoryKey]) {
              commitGroups[categoryKey].items.push(entry);
            } else {
              commitGroups.other.items.push(entry);
            }
          }
        });

        let output = '';
        
        // Generate output based on the categories order from YAML
        categories.forEach(category => {
          const key = category.title.replace(/[^\w\s]/g, '').replace(/\s+/g, '').toLowerCase();
          const group = commitGroups[key];
          if (group && group.items.length > 0) {
            output += `## ${group.title}\n\n`;
            group.items.forEach(item => {
              output += `- ${item}\n`;
            });
            output += '\n';
          }
        });
        
        // Add other changes if any
        if (commitGroups.other.items.length > 0) {
          output += `## ${commitGroups.other.title}\n\n`;
          commitGroups.other.items.forEach(item => {
            output += `- ${item}\n`;
          });
          output += '\n';
        }

        return output.trim();
      }}

include-paths: []
exclude-labels: ["skip-changelog"]
sort-direction: ascending
sort-by: committed_date
